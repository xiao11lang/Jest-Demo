### ES6 Class Mock

从本质上来说，es6引入的class是带有语法糖的构造函数，在底层，JavaScript仍是基于原型实现继承。在jest中，有四种方法来创建一个es6类的测试。

#### 自动模拟

调用jest.mock(modulePath)方法，jest将监视所有对该模块构造函数及方法的调用。这意味着该模块的导出的类会被模拟的构造函数替换，该类的实例方法会被mock函数替换，且这些mock函数默认返回undefined。

#### 手动模拟

通过在`__mocks__`文件夹中创建一个模拟实现来创建手动模拟。 这个可以指定实现，并且可以通过测试文件使用它。

#### 调用jest.mock并传入模块工厂函数

jest.mock()方法在调用时，可以传入额外的工厂函数作为第二个参数。该函数必须返回一个构造函数。意即该函数时一个高阶函数。

#### 使用mockImplementation 或mockImplementationOnce替换mock函数的实现

调用jest.mock()方法后，该模块导出的构造函数以及类实例的所有方法均称为mock函数，因此可以在这些mock函数上调用上述的两个方法，用于替换默认的实现。

总结：以上四种方法在本质上并无区别。自动模拟未替换类的实现，另外三种方法替换了类的实现。不同之处是替换实现的位置不同。手动模拟在单独的文件夹`__mocks__`中替换，此外还可以在调用jest.mock()的工厂中替换，或者在调用jest.mock()方法生成mock函数后用mockImplementation替换。核心都是经过jest.mock()处理后生成了mock函数，而mock函数具有相应的方法用于替换函数本身的实现。